"""Exploit Chain Composer — multi-step attack sequence synthesis.

Automatically composes multi-step exploit sequences by chaining atomic
attack primitives (flash loan → price manipulation → profit extraction).
Uses backward-chaining from a target vulnerable state to synthesize a
complete exploit path.

Architecture:
  ┌──────────────────────────────────────────────────────────────────┐
  │             EXPLOIT  CHAIN  COMPOSER                            │
  │                                                                  │
  │  ┌──────────┐  ┌────────────┐  ┌──────────────┐  ┌──────────┐ │
  │  │Primitive │─►│Constraint  │─►│Chain         │─►│Exploit   │ │
  │  │Library   │  │Solver      │  │Builder       │  │Validator │ │
  │  │          │  │            │  │              │  │          │ │
  │  └──────────┘  └────────────┘  └──────────────┘  └──────────┘ │
  │       │              │               │                   │      │
  │       ▼              ▼               ▼                   ▼      │
  │  ┌──────────┐  ┌────────────┐  ┌──────────────┐  ┌──────────┐ │
  │  │Goal      │  │Precondition│  │Sequence      │  │PoC Code  │ │
  │  │Analyzer  │  │Checker     │  │Optimizer     │  │Generator │ │
  │  │          │  │            │  │              │  │          │ │
  │  └──────────┘  └────────────┘  └──────────────┘  └──────────┘ │
  │                                                                  │
  │  ┌──────────────────────────────────────────────────────────┐   │
  │  │ Soul Protocol Attack Patterns (ZK proof forge, nullifier │   │
  │  │ replay, flash-loan-to-drain, bridge-relay-DOuble-spend,  │   │
  │  │ governance-takeover, privacy-pool-inflation)             │   │
  │  └──────────────────────────────────────────────────────────┘   │
  └──────────────────────────────────────────────────────────────────┘
"""

from __future__ import annotations

import hashlib
import logging
import time
from collections import defaultdict
from dataclasses import dataclass, field
from enum import Enum
from typing import Any

logger = logging.getLogger(__name__)


# ── Enums ────────────────────────────────────────────────────────────────────

class AttackPrimitiveType(Enum):
    """Atomic attack primitives that can be chained."""
    # Financial
    FLASH_LOAN_BORROW = "flash_loan_borrow"
    FLASH_LOAN_REPAY = "flash_loan_repay"
    LARGE_DEPOSIT = "large_deposit"
    LARGE_WITHDRAWAL = "large_withdrawal"
    PRICE_MANIPULATION = "price_manipulation"
    SANDWICH_FRONT = "sandwich_front"
    SANDWICH_BACK = "sandwich_back"

    # Access Control
    PRIVILEGE_ESCALATION = "privilege_escalation"
    OWNERSHIP_CLAIM = "ownership_claim"
    ROLE_MANIPULATION = "role_manipulation"
    PROXY_UPGRADE = "proxy_upgrade"

    # Re-entrancy
    REENTRANT_CALLBACK = "reentrant_callback"
    CROSS_FUNCTION_REENTRY = "cross_function_reentry"
    READ_ONLY_REENTRY = "read_only_reentry"

    # ZK-Specific
    PROOF_FORGERY = "proof_forgery"
    NULLIFIER_REPLAY = "nullifier_replay"
    MERKLE_ROOT_MANIPULATION = "merkle_root_manipulation"
    VERIFIER_BYPASS = "verifier_bypass"
    PUBLIC_INPUT_MANIPULATION = "public_input_manipulation"

    # State Manipulation
    STORAGE_COLLISION = "storage_collision"
    SLOT_OVERWRITE = "slot_overwrite"
    INITIALIZER_REPLAY = "initializer_replay"
    SELFDESTRUCT_TRIGGER = "selfdestruct_trigger"

    # Bridge / Cross-chain
    BRIDGE_MESSAGE_FORGE = "bridge_message_forge"
    RELAY_DOUBLE_SPEND = "relay_double_spend"
    CHAIN_ID_SPOOF = "chain_id_spoof"
    FINALITY_RACE = "finality_race"

    # Privacy Pool
    PRIVACY_POOL_INFLATION = "privacy_pool_inflation"
    DEPOSIT_WITHOUT_COMMITMENT = "deposit_without_commitment"
    WITHDRAW_WITH_STALE_ROOT = "withdraw_with_stale_root"

    # Timing / Ordering
    FRONT_RUN = "front_run"
    BACK_RUN = "back_run"
    TIME_MANIPULATION = "time_manipulation"
    BLOCK_STUFFING = "block_stuffing"

    # Governance
    GOVERNANCE_FLASH_VOTE = "governance_flash_vote"
    PROPOSAL_MANIPULATION = "proposal_manipulation"

    # Generic
    ARBITRARY_CALL = "arbitrary_call"
    SETUP_STATE = "setup_state"
    DRAIN_FUNDS = "drain_funds"


class ExploitGoal(Enum):
    """High-level exploit goals."""
    DRAIN_FUNDS = "drain_funds"
    DOUBLE_SPEND = "double_spend"
    PRIVILEGE_ESCALATION = "privilege_escalation"
    PROOF_BYPASS = "proof_bypass"
    NULLIFIER_REPLAY = "nullifier_replay"
    INFLATION_ATTACK = "inflation_attack"
    BRIDGE_DOUBLE_SPEND = "bridge_double_spend"
    GOVERNANCE_TAKEOVER = "governance_takeover"
    DOS_ATTACK = "dos_attack"
    PRIVACY_BREAK = "privacy_break"
    STORAGE_CORRUPTION = "storage_corruption"
    CONTRACT_DESTRUCTION = "contract_destruction"


class ChainStatus(Enum):
    """Status of an exploit chain."""
    BUILDING = "building"
    COMPLETE = "complete"
    VALIDATED = "validated"
    FAILED = "failed"
    PARTIAL = "partial"


# ── Data Classes ─────────────────────────────────────────────────────────────

@dataclass
class AttackPrecondition:
    """Precondition that must be met before an attack step."""
    description: str = ""
    state_requirements: dict[str, Any] = field(default_factory=dict)
    balance_requirements: dict[str, int] = field(default_factory=dict)
    role_requirements: list[str] = field(default_factory=list)
    timing_requirements: dict[str, Any] = field(default_factory=dict)


@dataclass
class AttackPostcondition:
    """Postcondition that should hold after an attack step."""
    description: str = ""
    state_changes: dict[str, Any] = field(default_factory=dict)
    balance_changes: dict[str, int] = field(default_factory=dict)
    events_emitted: list[str] = field(default_factory=list)


@dataclass
class AttackPrimitive:
    """An atomic attack step that can be chained."""
    id: str = ""
    type: AttackPrimitiveType = AttackPrimitiveType.ARBITRARY_CALL
    name: str = ""
    description: str = ""

    # Contract interaction
    target_contract: str = ""
    target_function: str = ""
    call_value: int = 0
    call_inputs: dict[str, Any] = field(default_factory=dict)

    # Conditions
    preconditions: list[AttackPrecondition] = field(default_factory=list)
    postconditions: list[AttackPostcondition] = field(default_factory=list)

    # Metadata
    gas_estimate: int = 0
    risk_level: str = "high"  # low, medium, high, critical
    soul_specific: bool = False
    compatible_with: list[AttackPrimitiveType] = field(default_factory=list)  # can chain after these

    def to_dict(self) -> dict[str, Any]:
        return {
            "id": self.id,
            "type": self.type.value,
            "name": self.name,
            "description": self.description,
            "target_contract": self.target_contract,
            "target_function": self.target_function,
            "call_value": self.call_value,
            "gas_estimate": self.gas_estimate,
            "risk_level": self.risk_level,
            "soul_specific": self.soul_specific,
        }


@dataclass
class ExploitStep:
    """A concrete step in an exploit chain."""
    step_index: int = 0
    primitive: AttackPrimitive = field(default_factory=AttackPrimitive)
    concrete_inputs: dict[str, Any] = field(default_factory=dict)
    concrete_value: int = 0
    expected_result: str = ""
    actual_result: str = ""
    gas_used: int = 0
    success: bool = False
    state_before_hash: str = ""
    state_after_hash: str = ""

    def to_dict(self) -> dict[str, Any]:
        return {
            "step": self.step_index,
            "primitive": self.primitive.to_dict(),
            "inputs": {k: str(v)[:100] for k, v in self.concrete_inputs.items()},
            "value": self.concrete_value,
            "expected": self.expected_result,
            "actual": self.actual_result,
            "gas_used": self.gas_used,
            "success": self.success,
        }


@dataclass
class ExploitChain:
    """A complete multi-step exploit chain."""
    chain_id: str = ""
    goal: ExploitGoal = ExploitGoal.DRAIN_FUNDS
    status: ChainStatus = ChainStatus.BUILDING
    steps: list[ExploitStep] = field(default_factory=list)

    # Target
    target_contract: str = ""
    target_invariant: str = ""

    # Impact
    estimated_impact: str = ""
    profit_estimate: int = 0

    # Validation
    validated: bool = False
    validation_result: str = ""

    # PoC
    poc_code: str = ""

    # Metadata
    created_at: float = 0.0
    complexity: int = 0  # number of steps
    soul_relevance: float = 0.0

    def to_dict(self) -> dict[str, Any]:
        return {
            "chain_id": self.chain_id,
            "goal": self.goal.value,
            "status": self.status.value,
            "steps": [s.to_dict() for s in self.steps],
            "target_contract": self.target_contract,
            "target_invariant": self.target_invariant,
            "estimated_impact": self.estimated_impact,
            "profit_estimate": self.profit_estimate,
            "validated": self.validated,
            "complexity": self.complexity,
            "soul_relevance": self.soul_relevance,
            "poc_code": self.poc_code[:500] + "..." if len(self.poc_code) > 500 else self.poc_code,
        }


@dataclass
class ComposerResult:
    """Result of exploit chain composition."""
    chains: list[ExploitChain] = field(default_factory=list)
    primitives_available: int = 0
    combinations_explored: int = 0
    valid_chains: int = 0
    composition_time_sec: float = 0.0

    # By goal
    by_goal: dict[str, int] = field(default_factory=dict)
    by_status: dict[str, int] = field(default_factory=dict)

    def to_dict(self) -> dict[str, Any]:
        return {
            "chains": [c.to_dict() for c in self.chains],
            "primitives_available": self.primitives_available,
            "combinations_explored": self.combinations_explored,
            "valid_chains": self.valid_chains,
            "composition_time_sec": round(self.composition_time_sec, 2),
            "by_goal": self.by_goal,
            "by_status": self.by_status,
            "summary": {
                "total": len(self.chains),
                "validated": sum(1 for c in self.chains if c.validated),
                "critical": sum(
                    1 for c in self.chains
                    if c.goal in (ExploitGoal.DRAIN_FUNDS, ExploitGoal.DOUBLE_SPEND)
                ),
            },
        }


# ── Attack Primitive Library ─────────────────────────────────────────────────

class AttackPrimitiveLibrary:
    """Library of atomic attack primitives for chain composition."""

    def __init__(self) -> None:
        self._primitives: dict[str, AttackPrimitive] = {}
        self._register_all()

    def _register_all(self) -> None:
        """Register all attack primitives."""
        self._register_financial()
        self._register_zk_specific()
        self._register_reentry()
        self._register_access_control()
        self._register_bridge()
        self._register_privacy_pool()
        self._register_state_manipulation()
        self._register_governance()
        self._register_timing()

    def _register_financial(self) -> None:
        self._add(AttackPrimitive(
            id="fin-001",
            type=AttackPrimitiveType.FLASH_LOAN_BORROW,
            name="Flash Loan Borrow",
            description="Borrow large amount via flash loan (Aave/dYdX)",
            target_function="flashLoan",
            gas_estimate=300000,
            postconditions=[AttackPostcondition(
                description="Large token balance available for attack",
                balance_changes={"attacker": 10**24},
            )],
            compatible_with=[
                AttackPrimitiveType.SETUP_STATE,
            ],
        ))

        self._add(AttackPrimitive(
            id="fin-002",
            type=AttackPrimitiveType.FLASH_LOAN_REPAY,
            name="Flash Loan Repay",
            description="Repay flash loan with profit",
            target_function="repay",
            gas_estimate=100000,
            preconditions=[AttackPrecondition(
                description="Must have funds to repay + fee",
            )],
        ))

        self._add(AttackPrimitive(
            id="fin-003",
            type=AttackPrimitiveType.LARGE_DEPOSIT,
            name="Large Deposit",
            description="Deposit large amount to privacy pool",
            target_function="deposit",
            gas_estimate=500000,
            soul_specific=True,
            compatible_with=[
                AttackPrimitiveType.FLASH_LOAN_BORROW,
            ],
        ))

        self._add(AttackPrimitive(
            id="fin-004",
            type=AttackPrimitiveType.LARGE_WITHDRAWAL,
            name="Large Withdrawal",
            description="Withdraw from privacy pool",
            target_function="withdraw",
            gas_estimate=600000,
            soul_specific=True,
        ))

        self._add(AttackPrimitive(
            id="fin-005",
            type=AttackPrimitiveType.PRICE_MANIPULATION,
            name="Price Manipulation",
            description="Manipulate oracle/AMM price",
            target_function="swap",
            gas_estimate=400000,
            compatible_with=[
                AttackPrimitiveType.FLASH_LOAN_BORROW,
            ],
        ))

        self._add(AttackPrimitive(
            id="fin-006",
            type=AttackPrimitiveType.DRAIN_FUNDS,
            name="Drain Funds",
            description="Extract value from vulnerable contract",
            target_function="withdraw",
            gas_estimate=200000,
        ))

        self._add(AttackPrimitive(
            id="fin-007",
            type=AttackPrimitiveType.SANDWICH_FRONT,
            name="Sandwich Front-Run",
            description="Front-run a victim swap with a large same-direction trade",
            target_function="swap",
            gas_estimate=250000,
            risk_level="high",
            compatible_with=[AttackPrimitiveType.FLASH_LOAN_BORROW],
        ))

        self._add(AttackPrimitive(
            id="fin-008",
            type=AttackPrimitiveType.SANDWICH_BACK,
            name="Sandwich Back-Run",
            description="Back-run a victim swap to capture the slippage profit",
            target_function="swap",
            gas_estimate=250000,
            risk_level="high",
            compatible_with=[AttackPrimitiveType.SANDWICH_FRONT],
        ))

    def _register_zk_specific(self) -> None:
        self._add(AttackPrimitive(
            id="zk-001",
            type=AttackPrimitiveType.PROOF_FORGERY,
            name="ZK Proof Forgery",
            description="Submit forged/manipulated ZK proof",
            target_function="verify",
            gas_estimate=800000,
            soul_specific=True,
            risk_level="critical",
            compatible_with=[
                AttackPrimitiveType.SETUP_STATE,
                AttackPrimitiveType.PUBLIC_INPUT_MANIPULATION,
            ],
        ))

        self._add(AttackPrimitive(
            id="zk-002",
            type=AttackPrimitiveType.NULLIFIER_REPLAY,
            name="Nullifier Replay",
            description="Replay a previously-used nullifier",
            target_function="registerNullifier",
            gas_estimate=200000,
            soul_specific=True,
            risk_level="critical",
            preconditions=[AttackPrecondition(
                description="Must know a valid nullifier from previous tx",
            )],
        ))

        self._add(AttackPrimitive(
            id="zk-003",
            type=AttackPrimitiveType.MERKLE_ROOT_MANIPULATION,
            name="Merkle Root Manipulation",
            description="Use stale or crafted Merkle root",
            target_function="withdraw",
            gas_estimate=400000,
            soul_specific=True,
            risk_level="critical",
        ))

        self._add(AttackPrimitive(
            id="zk-004",
            type=AttackPrimitiveType.VERIFIER_BYPASS,
            name="Verifier Bypass",
            description="Bypass ZK verifier through input manipulation",
            target_function="verifyProof",
            gas_estimate=600000,
            soul_specific=True,
            risk_level="critical",
        ))

        self._add(AttackPrimitive(
            id="zk-005",
            type=AttackPrimitiveType.PUBLIC_INPUT_MANIPULATION,
            name="Public Input Manipulation",
            description="Manipulate public inputs to ZK circuit",
            target_function="verifyProof",
            gas_estimate=300000,
            soul_specific=True,
            risk_level="critical",
        ))

    def _register_reentry(self) -> None:
        self._add(AttackPrimitive(
            id="re-001",
            type=AttackPrimitiveType.REENTRANT_CALLBACK,
            name="Reentrancy Callback",
            description="Re-enter vulnerable function via callback",
            target_function="withdraw",
            gas_estimate=500000,
            risk_level="critical",
        ))

        self._add(AttackPrimitive(
            id="re-002",
            type=AttackPrimitiveType.CROSS_FUNCTION_REENTRY,
            name="Cross-Function Reentrancy",
            description="Re-enter different function during callback",
            target_function="withdraw",
            gas_estimate=600000,
            risk_level="critical",
        ))

        self._add(AttackPrimitive(
            id="re-003",
            type=AttackPrimitiveType.READ_ONLY_REENTRY,
            name="Read-Only Reentrancy",
            description="Exploit stale read during reentrancy",
            target_function="getPrice",
            gas_estimate=400000,
            risk_level="high",
        ))

    def _register_access_control(self) -> None:
        self._add(AttackPrimitive(
            id="ac-001",
            type=AttackPrimitiveType.PRIVILEGE_ESCALATION,
            name="Privilege Escalation",
            description="Escalate from user to admin/owner",
            target_function="grantRole",
            gas_estimate=200000,
            risk_level="critical",
        ))

        self._add(AttackPrimitive(
            id="ac-004",
            type=AttackPrimitiveType.ROLE_MANIPULATION,
            name="Role Manipulation",
            description="Manipulate access-control roles via unguarded setter",
            target_function="setRole",
            gas_estimate=150000,
            risk_level="critical",
        ))

        self._add(AttackPrimitive(
            id="ac-002",
            type=AttackPrimitiveType.OWNERSHIP_CLAIM,
            name="Ownership Claim",
            description="Claim contract ownership",
            target_function="transferOwnership",
            gas_estimate=100000,
            risk_level="critical",
        ))

        self._add(AttackPrimitive(
            id="ac-003",
            type=AttackPrimitiveType.PROXY_UPGRADE,
            name="Malicious Proxy Upgrade",
            description="Upgrade proxy to malicious implementation",
            target_function="upgradeTo",
            gas_estimate=300000,
            risk_level="critical",
        ))

    def _register_bridge(self) -> None:
        self._add(AttackPrimitive(
            id="br-001",
            type=AttackPrimitiveType.BRIDGE_MESSAGE_FORGE,
            name="Bridge Message Forgery",
            description="Forge cross-chain bridge message",
            target_function="relayProof",
            gas_estimate=500000,
            soul_specific=True,
            risk_level="critical",
        ))

        self._add(AttackPrimitive(
            id="br-002",
            type=AttackPrimitiveType.RELAY_DOUBLE_SPEND,
            name="Relay Double Spend",
            description="Double-spend via relay proof replay",
            target_function="relayProof",
            gas_estimate=400000,
            soul_specific=True,
            risk_level="critical",
        ))

        self._add(AttackPrimitive(
            id="br-003",
            type=AttackPrimitiveType.CHAIN_ID_SPOOF,
            name="Chain ID Spoof",
            description="Spoof source chain ID in bridge message",
            target_function="relayMessage",
            gas_estimate=200000,
            soul_specific=True,
            risk_level="high",
        ))

        self._add(AttackPrimitive(
            id="br-004",
            type=AttackPrimitiveType.FINALITY_RACE,
            name="Finality Race",
            description="Exploit race condition between L1 finality and L2 relay",
            target_function="relayProof",
            gas_estimate=300000,
            soul_specific=True,
            risk_level="high",
        ))

    def _register_privacy_pool(self) -> None:
        self._add(AttackPrimitive(
            id="pp-001",
            type=AttackPrimitiveType.PRIVACY_POOL_INFLATION,
            name="Privacy Pool Inflation",
            description="Inflate pool balance beyond actual deposits",
            target_function="deposit",
            gas_estimate=800000,
            soul_specific=True,
            risk_level="critical",
        ))

        self._add(AttackPrimitive(
            id="pp-002",
            type=AttackPrimitiveType.DEPOSIT_WITHOUT_COMMITMENT,
            name="Deposit Without Commitment",
            description="Deposit to pool without valid commitment",
            target_function="deposit",
            gas_estimate=400000,
            soul_specific=True,
            risk_level="critical",
        ))

        self._add(AttackPrimitive(
            id="pp-003",
            type=AttackPrimitiveType.WITHDRAW_WITH_STALE_ROOT,
            name="Withdraw With Stale Root",
            description="Withdraw using old/stale Merkle root",
            target_function="withdraw",
            gas_estimate=500000,
            soul_specific=True,
            risk_level="critical",
        ))

    def _register_state_manipulation(self) -> None:
        self._add(AttackPrimitive(
            id="st-001",
            type=AttackPrimitiveType.STORAGE_COLLISION,
            name="Storage Collision",
            description="Exploit storage slot collision between proxy/impl",
            target_function="upgradeTo",
            gas_estimate=200000,
            risk_level="critical",
        ))

        self._add(AttackPrimitive(
            id="st-005",
            type=AttackPrimitiveType.SLOT_OVERWRITE,
            name="Slot Overwrite",
            description="Directly overwrite a storage slot via delegatecall or assembly",
            target_function="delegatecall",
            gas_estimate=150000,
            risk_level="critical",
        ))

        self._add(AttackPrimitive(
            id="st-002",
            type=AttackPrimitiveType.INITIALIZER_REPLAY,
            name="Initializer Replay",
            description="Re-call initializer on unprotected contract",
            target_function="initialize",
            gas_estimate=200000,
            risk_level="critical",
        ))

        self._add(AttackPrimitive(
            id="st-003",
            type=AttackPrimitiveType.SELFDESTRUCT_TRIGGER,
            name="Selfdestruct Trigger",
            description="Trigger selfdestruct via implementation",
            target_function="destroy",
            gas_estimate=100000,
            risk_level="critical",
        ))

        self._add(AttackPrimitive(
            id="st-004",
            type=AttackPrimitiveType.SETUP_STATE,
            name="Setup State",
            description="Set up required state for exploit",
            target_function="setUp",
            gas_estimate=200000,
            risk_level="low",
        ))

    def _register_governance(self) -> None:
        self._add(AttackPrimitive(
            id="gov-001",
            type=AttackPrimitiveType.GOVERNANCE_FLASH_VOTE,
            name="Governance Flash Vote",
            description="Flash loan tokens → vote → repay in same block",
            target_function="castVote",
            gas_estimate=1000000,
            risk_level="high",
        ))

        self._add(AttackPrimitive(
            id="gov-002",
            type=AttackPrimitiveType.PROPOSAL_MANIPULATION,
            name="Proposal Manipulation",
            description="Submit malicious governance proposal",
            target_function="propose",
            gas_estimate=500000,
            risk_level="high",
        ))

    def _register_timing(self) -> None:
        self._add(AttackPrimitive(
            id="tm-001",
            type=AttackPrimitiveType.FRONT_RUN,
            name="Front-Run",
            description="Front-run a pending transaction",
            target_function="swap",
            gas_estimate=100000,
            risk_level="medium",
        ))

        self._add(AttackPrimitive(
            id="tm-002",
            type=AttackPrimitiveType.TIME_MANIPULATION,
            name="Time Manipulation",
            description="Exploit timestamp dependency",
            target_function="unlock",
            gas_estimate=50000,
            risk_level="medium",
        ))

        self._add(AttackPrimitive(
            id="tm-003",
            type=AttackPrimitiveType.BLOCK_STUFFING,
            name="Block Stuffing",
            description="Fill block to prevent others from transacting",
            target_function="transfer",
            gas_estimate=30000000,
            risk_level="high",
        ))

        self._add(AttackPrimitive(
            id="tm-004",
            type=AttackPrimitiveType.BACK_RUN,
            name="Back-Run",
            description="Back-run a victim transaction to capture arbitrage",
            target_function="swap",
            gas_estimate=150000,
            risk_level="medium",
            compatible_with=[AttackPrimitiveType.FRONT_RUN],
        ))

    def _add(self, primitive: AttackPrimitive) -> None:
        self._primitives[primitive.id] = primitive

    def get_all(self) -> list[AttackPrimitive]:
        return list(self._primitives.values())

    def get_by_type(self, ptype: AttackPrimitiveType) -> list[AttackPrimitive]:
        return [p for p in self._primitives.values() if p.type == ptype]

    def get_by_goal(self, goal: ExploitGoal) -> list[AttackPrimitive]:
        """Get primitives relevant to a goal."""
        goal_primitives: dict[ExploitGoal, list[AttackPrimitiveType]] = {
            ExploitGoal.DRAIN_FUNDS: [
                AttackPrimitiveType.FLASH_LOAN_BORROW,
                AttackPrimitiveType.REENTRANT_CALLBACK,
                AttackPrimitiveType.LARGE_WITHDRAWAL,
                AttackPrimitiveType.DRAIN_FUNDS,
                AttackPrimitiveType.FLASH_LOAN_REPAY,
            ],
            ExploitGoal.DOUBLE_SPEND: [
                AttackPrimitiveType.NULLIFIER_REPLAY,
                AttackPrimitiveType.RELAY_DOUBLE_SPEND,
            ],
            ExploitGoal.PROOF_BYPASS: [
                AttackPrimitiveType.PROOF_FORGERY,
                AttackPrimitiveType.VERIFIER_BYPASS,
                AttackPrimitiveType.PUBLIC_INPUT_MANIPULATION,
            ],
            ExploitGoal.NULLIFIER_REPLAY: [
                AttackPrimitiveType.NULLIFIER_REPLAY,
                AttackPrimitiveType.SETUP_STATE,
            ],
            ExploitGoal.INFLATION_ATTACK: [
                AttackPrimitiveType.PRIVACY_POOL_INFLATION,
                AttackPrimitiveType.DEPOSIT_WITHOUT_COMMITMENT,
                AttackPrimitiveType.FLASH_LOAN_BORROW,
            ],
            ExploitGoal.BRIDGE_DOUBLE_SPEND: [
                AttackPrimitiveType.BRIDGE_MESSAGE_FORGE,
                AttackPrimitiveType.RELAY_DOUBLE_SPEND,
                AttackPrimitiveType.CHAIN_ID_SPOOF,
            ],
            ExploitGoal.GOVERNANCE_TAKEOVER: [
                AttackPrimitiveType.GOVERNANCE_FLASH_VOTE,
                AttackPrimitiveType.FLASH_LOAN_BORROW,
                AttackPrimitiveType.PROPOSAL_MANIPULATION,
            ],
            ExploitGoal.PRIVILEGE_ESCALATION: [
                AttackPrimitiveType.PRIVILEGE_ESCALATION,
                AttackPrimitiveType.OWNERSHIP_CLAIM,
                AttackPrimitiveType.PROXY_UPGRADE,
                AttackPrimitiveType.INITIALIZER_REPLAY,
            ],
            ExploitGoal.DOS_ATTACK: [
                AttackPrimitiveType.BLOCK_STUFFING,
                AttackPrimitiveType.LARGE_DEPOSIT,
            ],
            ExploitGoal.STORAGE_CORRUPTION: [
                AttackPrimitiveType.STORAGE_COLLISION,
                AttackPrimitiveType.SLOT_OVERWRITE,
                AttackPrimitiveType.PROXY_UPGRADE,
            ],
        }

        relevant_types = goal_primitives.get(goal, [])
        return [
            p for p in self._primitives.values()
            if p.type in relevant_types
        ]

    @property
    def primitive_count(self) -> int:
        return len(self._primitives)


# ── Chain Builder ────────────────────────────────────────────────────────────

class ExploitChainBuilder:
    """Builds exploit chains from primitives using backward-chaining."""

    def __init__(
        self,
        library: AttackPrimitiveLibrary,
        max_chain_length: int = 10,
        max_chains: int = 50,
    ) -> None:
        self._library = library
        self._max_chain_length = max_chain_length
        self._max_chains = max_chains

    def build_chains(
        self,
        goal: ExploitGoal,
        target_contract: str = "",
        target_invariant: str = "",
        findings: list[dict[str, Any]] | None = None,
    ) -> list[ExploitChain]:
        """Build exploit chains for a given goal."""
        chains: list[ExploitChain] = []

        # Get relevant primitives
        primitives = self._library.get_by_goal(goal)
        if not primitives:
            return chains

        # Generate chain templates based on goal
        templates = self._get_chain_templates(goal)

        for template in templates:
            chain = self._instantiate_template(
                template=template,
                goal=goal,
                target_contract=target_contract,
                target_invariant=target_invariant,
                primitives=primitives,
            )
            if chain:
                chains.append(chain)

        # Generate discovery-based chains from findings
        if findings:
            finding_chains = self._chains_from_findings(
                findings, goal, target_contract,
            )
            chains.extend(finding_chains)

        # Limit
        chains = chains[:self._max_chains]

        return chains

    def _get_chain_templates(
        self, goal: ExploitGoal,
    ) -> list[list[AttackPrimitiveType]]:
        """Get predefined chain templates for a goal."""
        templates: dict[ExploitGoal, list[list[AttackPrimitiveType]]] = {
            ExploitGoal.DRAIN_FUNDS: [
                # Flash loan drain
                [
                    AttackPrimitiveType.FLASH_LOAN_BORROW,
                    AttackPrimitiveType.LARGE_DEPOSIT,
                    AttackPrimitiveType.REENTRANT_CALLBACK,
                    AttackPrimitiveType.LARGE_WITHDRAWAL,
                    AttackPrimitiveType.DRAIN_FUNDS,
                    AttackPrimitiveType.FLASH_LOAN_REPAY,
                ],
                # Reentrancy drain
                [
                    AttackPrimitiveType.SETUP_STATE,
                    AttackPrimitiveType.REENTRANT_CALLBACK,
                    AttackPrimitiveType.DRAIN_FUNDS,
                ],
                # Price manipulation drain
                [
                    AttackPrimitiveType.FLASH_LOAN_BORROW,
                    AttackPrimitiveType.PRICE_MANIPULATION,
                    AttackPrimitiveType.LARGE_WITHDRAWAL,
                    AttackPrimitiveType.FLASH_LOAN_REPAY,
                ],
            ],
            ExploitGoal.DOUBLE_SPEND: [
                [
                    AttackPrimitiveType.SETUP_STATE,
                    AttackPrimitiveType.NULLIFIER_REPLAY,
                    AttackPrimitiveType.LARGE_WITHDRAWAL,
                ],
                [
                    AttackPrimitiveType.RELAY_DOUBLE_SPEND,
                    AttackPrimitiveType.DRAIN_FUNDS,
                ],
            ],
            ExploitGoal.PROOF_BYPASS: [
                [
                    AttackPrimitiveType.PUBLIC_INPUT_MANIPULATION,
                    AttackPrimitiveType.PROOF_FORGERY,
                    AttackPrimitiveType.LARGE_WITHDRAWAL,
                ],
                [
                    AttackPrimitiveType.VERIFIER_BYPASS,
                    AttackPrimitiveType.DRAIN_FUNDS,
                ],
            ],
            ExploitGoal.INFLATION_ATTACK: [
                [
                    AttackPrimitiveType.FLASH_LOAN_BORROW,
                    AttackPrimitiveType.DEPOSIT_WITHOUT_COMMITMENT,
                    AttackPrimitiveType.PRIVACY_POOL_INFLATION,
                    AttackPrimitiveType.LARGE_WITHDRAWAL,
                    AttackPrimitiveType.FLASH_LOAN_REPAY,
                ],
            ],
            ExploitGoal.BRIDGE_DOUBLE_SPEND: [
                [
                    AttackPrimitiveType.BRIDGE_MESSAGE_FORGE,
                    AttackPrimitiveType.RELAY_DOUBLE_SPEND,
                    AttackPrimitiveType.DRAIN_FUNDS,
                ],
                [
                    AttackPrimitiveType.CHAIN_ID_SPOOF,
                    AttackPrimitiveType.BRIDGE_MESSAGE_FORGE,
                    AttackPrimitiveType.DRAIN_FUNDS,
                ],
            ],
            ExploitGoal.GOVERNANCE_TAKEOVER: [
                [
                    AttackPrimitiveType.FLASH_LOAN_BORROW,
                    AttackPrimitiveType.GOVERNANCE_FLASH_VOTE,
                    AttackPrimitiveType.PROPOSAL_MANIPULATION,
                    AttackPrimitiveType.FLASH_LOAN_REPAY,
                ],
            ],
            ExploitGoal.PRIVILEGE_ESCALATION: [
                [
                    AttackPrimitiveType.INITIALIZER_REPLAY,
                    AttackPrimitiveType.OWNERSHIP_CLAIM,
                    AttackPrimitiveType.PROXY_UPGRADE,
                ],
                [
                    AttackPrimitiveType.STORAGE_COLLISION,
                    AttackPrimitiveType.PRIVILEGE_ESCALATION,
                ],
            ],
            ExploitGoal.STORAGE_CORRUPTION: [
                [
                    AttackPrimitiveType.STORAGE_COLLISION,
                    AttackPrimitiveType.SLOT_OVERWRITE,
                ],
                [
                    AttackPrimitiveType.PROXY_UPGRADE,
                    AttackPrimitiveType.STORAGE_COLLISION,
                ],
            ],
        }

        return templates.get(goal, [[AttackPrimitiveType.ARBITRARY_CALL]])

    def _instantiate_template(
        self,
        template: list[AttackPrimitiveType],
        goal: ExploitGoal,
        target_contract: str,
        target_invariant: str,
        primitives: list[AttackPrimitive],
    ) -> ExploitChain | None:
        """Instantiate a chain template with concrete primitives."""
        chain_id = hashlib.sha256(
            f"{goal.value}:{':'.join(t.value for t in template)}:{time.time()}".encode()
        ).hexdigest()[:12]

        chain = ExploitChain(
            chain_id=f"chain-{chain_id}",
            goal=goal,
            status=ChainStatus.COMPLETE,
            target_contract=target_contract,
            target_invariant=target_invariant,
            created_at=time.time(),
            complexity=len(template),
            soul_relevance=self._compute_soul_relevance(template),
        )

        primitive_map = {}
        for p in primitives:
            primitive_map.setdefault(p.type, []).append(p)

        # Also check full library
        all_primitives = self._library.get_all()
        for p in all_primitives:
            primitive_map.setdefault(p.type, []).append(p)

        for idx, ptype in enumerate(template):
            available = primitive_map.get(ptype, [])
            if not available:
                chain.status = ChainStatus.PARTIAL
                continue

            primitive = available[0]
            step = ExploitStep(
                step_index=idx,
                primitive=primitive,
                concrete_inputs=primitive.call_inputs.copy(),
                concrete_value=primitive.call_value,
                expected_result=f"Step {idx}: {primitive.name}",
            )
            chain.steps.append(step)

        # Estimate impact
        chain.estimated_impact = self._estimate_impact(goal, chain)

        return chain

    def _chains_from_findings(
        self,
        findings: list[dict[str, Any]],
        goal: ExploitGoal,
        target_contract: str,
    ) -> list[ExploitChain]:
        """Generate exploit chains from fuzzing findings."""
        chains: list[ExploitChain] = []

        for finding in findings:
            severity = finding.get("severity", "")
            if severity not in ("CRITICAL", "HIGH", "critical", "high"):
                continue

            # Map finding to attack primitive
            mutation = finding.get("mutation", "")
            ptype = self._mutation_to_primitive(mutation)
            if ptype:
                chain = ExploitChain(
                    chain_id=f"finding-{hashlib.sha256(str(finding).encode()).hexdigest()[:8]}",
                    goal=goal,
                    status=ChainStatus.BUILDING,
                    target_contract=target_contract,
                    target_invariant=finding.get("invariant_id", ""),
                    created_at=time.time(),
                    soul_relevance=0.8,
                )

                # Add setup step
                setup = self._library.get_by_type(AttackPrimitiveType.SETUP_STATE)
                if setup:
                    chain.steps.append(ExploitStep(
                        step_index=0,
                        primitive=setup[0],
                    ))

                # Add finding-derived step
                matching = self._library.get_by_type(ptype)
                if matching:
                    chain.steps.append(ExploitStep(
                        step_index=1,
                        primitive=matching[0],
                        concrete_inputs=finding.get("input", {}).get("values", {}),
                    ))

                chain.complexity = len(chain.steps)
                chains.append(chain)

        return chains

    def _mutation_to_primitive(
        self, mutation: str,
    ) -> AttackPrimitiveType | None:
        """Map a mutation type to an attack primitive."""
        mapping = {
            "corrupt_proof": AttackPrimitiveType.PROOF_FORGERY,
            "replay_nullifier": AttackPrimitiveType.NULLIFIER_REPLAY,
            "stale_merkle_root": AttackPrimitiveType.MERKLE_ROOT_MANIPULATION,
            "wrong_verifier": AttackPrimitiveType.VERIFIER_BYPASS,
            "invalid_public_inputs": AttackPrimitiveType.PUBLIC_INPUT_MANIPULATION,
            "flash_loan_sequence": AttackPrimitiveType.FLASH_LOAN_BORROW,
            "interesting_address": AttackPrimitiveType.PRIVILEGE_ESCALATION,
            "storage_collision": AttackPrimitiveType.STORAGE_COLLISION,
            "duplicate_relay": AttackPrimitiveType.RELAY_DOUBLE_SPEND,
            "wrong_chain_id": AttackPrimitiveType.CHAIN_ID_SPOOF,
            "invalid_bridge_message": AttackPrimitiveType.BRIDGE_MESSAGE_FORGE,
        }
        return mapping.get(mutation)

    def _compute_soul_relevance(
        self, template: list[AttackPrimitiveType],
    ) -> float:
        """Compute Soul Protocol relevance of a chain template."""
        soul_types = {
            AttackPrimitiveType.PROOF_FORGERY,
            AttackPrimitiveType.NULLIFIER_REPLAY,
            AttackPrimitiveType.MERKLE_ROOT_MANIPULATION,
            AttackPrimitiveType.VERIFIER_BYPASS,
            AttackPrimitiveType.PUBLIC_INPUT_MANIPULATION,
            AttackPrimitiveType.BRIDGE_MESSAGE_FORGE,
            AttackPrimitiveType.RELAY_DOUBLE_SPEND,
            AttackPrimitiveType.CHAIN_ID_SPOOF,
            AttackPrimitiveType.PRIVACY_POOL_INFLATION,
            AttackPrimitiveType.DEPOSIT_WITHOUT_COMMITMENT,
            AttackPrimitiveType.WITHDRAW_WITH_STALE_ROOT,
        }
        soul_count = sum(1 for t in template if t in soul_types)
        return round(soul_count / max(len(template), 1), 2)

    def _estimate_impact(self, goal: ExploitGoal, chain: ExploitChain) -> str:
        """Estimate exploit impact."""
        impact_map = {
            ExploitGoal.DRAIN_FUNDS: "Complete fund drainage — total loss of contract value",
            ExploitGoal.DOUBLE_SPEND: "Double-spend attack — token inflation and fund theft",
            ExploitGoal.PRIVILEGE_ESCALATION: "Privilege escalation — unauthorized admin control",
            ExploitGoal.PROOF_BYPASS: "ZK proof bypass — unauthorized state transitions",
            ExploitGoal.NULLIFIER_REPLAY: "Nullifier replay — double-spend via replay",
            ExploitGoal.INFLATION_ATTACK: "Pool inflation — withdraw more than deposited",
            ExploitGoal.BRIDGE_DOUBLE_SPEND: "Bridge double-spend — cross-chain fund theft",
            ExploitGoal.GOVERNANCE_TAKEOVER: "Governance takeover — malicious proposal execution",
            ExploitGoal.DOS_ATTACK: "Denial of service — contract unavailable",
            ExploitGoal.STORAGE_CORRUPTION: "Storage corruption — undefined contract behavior",
        }
        return impact_map.get(goal, "Unknown impact")


# ── PoC Generator ────────────────────────────────────────────────────────────

class ExploitPoCGenerator:
    """Generates Foundry test PoC code from exploit chains."""

    def generate(
        self,
        chain: ExploitChain,
        contract_name: str = "Target",
    ) -> str:
        """Generate Foundry test PoC for an exploit chain."""
        steps_code = []
        for step in chain.steps:
            step_code = self._generate_step_code(step, contract_name)
            steps_code.append(step_code)

        steps_block = "\n\n".join(steps_code) if steps_code else "        // No steps"

        # Build goal-specific verification assertion
        verification_block = self._generate_verification(chain)

        return f"""// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Test.sol";
import "../src/{contract_name}.sol";

/**
 * @title Exploit PoC: {chain.goal.value}
 * @notice Generated by ZASEON Exploit Chain Composer
 * @dev Chain ID: {chain.chain_id}
 *      Goal: {chain.goal.value}
 *      Complexity: {chain.complexity} steps
 *      Impact: {chain.estimated_impact}
 *      Soul Relevance: {chain.soul_relevance}
 */
contract Exploit_{chain.chain_id.replace("-", "_")} is Test {{
    {contract_name} target;
    address attacker = makeAddr("attacker");

    function setUp() public {{
        target = new {contract_name}();
        vm.deal(attacker, 100 ether);
    }}

    function test_exploit_{chain.goal.value}() public {{
        vm.startPrank(attacker);

{steps_block}

        vm.stopPrank();

        // Verify exploit success
        // Goal: {chain.goal.value}
        // Expected impact: {chain.estimated_impact}
{verification_block}
    }}
}}
"""

    def _generate_verification(self, chain: ExploitChain) -> str:
        """Generate goal-specific verification assertions for an exploit PoC."""
        goal = chain.goal
        lines = []

        if goal == ExploitGoal.DRAIN_FUNDS:
            lines.append("        // Verify funds were drained from target")
            lines.append("        assertGt(attacker.balance, 100 ether, \"Attacker should have gained funds\");")
            lines.append("        assertEq(address(target).balance, 0, \"Target should be drained\");")
        elif goal == ExploitGoal.DOUBLE_SPEND:
            lines.append("        // Verify double-spend occurred")
            lines.append("        assertGt(attacker.balance, 100 ether, \"Attacker gained from double-spend\");")
        elif goal == ExploitGoal.PRIVILEGE_ESCALATION:
            lines.append("        // Verify attacker gained elevated privileges")
            lines.append("        assertTrue(target.hasRole(target.DEFAULT_ADMIN_ROLE(), attacker), \"Attacker should have admin role\");")
        elif goal == ExploitGoal.PROOF_BYPASS:
            lines.append("        // Verify ZK proof bypass — state changed without valid proof")
            lines.append("        assertTrue(true, \"State change succeeded without valid proof — manual verification needed\");")
        elif goal == ExploitGoal.NULLIFIER_REPLAY:
            lines.append("        // Verify nullifier was replayed — attacker balance increased")
            lines.append("        assertGt(attacker.balance, 100 ether, \"Nullifier replay succeeded\");")
        elif goal == ExploitGoal.INFLATION_ATTACK:
            lines.append("        // Verify pool inflation — withdrew more than deposited")
            lines.append("        assertGt(attacker.balance, 100 ether, \"Attacker inflated pool balance\");")
        elif goal == ExploitGoal.BRIDGE_DOUBLE_SPEND:
            lines.append("        // Verify bridge double-spend")
            lines.append("        assertGt(attacker.balance, 100 ether, \"Bridge double-spend succeeded\");")
        elif goal == ExploitGoal.GOVERNANCE_TAKEOVER:
            lines.append("        // Verify governance takeover")
            lines.append("        assertTrue(target.hasRole(target.DEFAULT_ADMIN_ROLE(), attacker), \"Governance takeover succeeded\");")
        elif goal == ExploitGoal.DOS_ATTACK:
            lines.append("        // Verify denial of service — target function reverts")
            lines.append("        vm.expectRevert();")
            lines.append("        target.normalOperation();")
        elif goal == ExploitGoal.PRIVACY_BREAK:
            lines.append("        // Verify privacy break — sensitive data exposed")
            lines.append("        assertTrue(true, \"Privacy break — sensitive state exposed, manual review needed\");")
        elif goal == ExploitGoal.STORAGE_CORRUPTION:
            lines.append("        // Verify storage corruption impact")
            lines.append("        assertTrue(address(target).code.length > 0, \"Target still has code\");")
        elif goal == ExploitGoal.CONTRACT_DESTRUCTION:
            lines.append("        // Verify contract destroyed")
            lines.append("        assertEq(address(target).code.length, 0, \"Target should be destroyed\");")
        else:
            lines.append("        // Verify exploit impact")
            lines.append("        assertTrue(address(target).code.length > 0, \"Target contract state changed\");")

        return "\n".join(lines)

    def _generate_step_code(
        self, step: ExploitStep, contract_name: str,
    ) -> str:
        """Generate code for a single exploit step."""
        primitive = step.primitive
        lines = [
            f"        // Step {step.step_index}: {primitive.name}",
            f"        // {primitive.description}",
        ]

        if primitive.target_function:
            if step.concrete_value > 0:
                lines.append(
                    f"        target.{primitive.target_function}{{value: {step.concrete_value}}}("
                )
            else:
                lines.append(
                    f"        target.{primitive.target_function}("
                )

            # Add inputs
            input_parts = []
            for k, v in step.concrete_inputs.items():
                if isinstance(v, int):
                    input_parts.append(f"            {v}")
                elif isinstance(v, str) and v.startswith("0x"):
                    input_parts.append(f"            {v}")
                elif isinstance(v, bytes):
                    input_parts.append(f'            hex"{v.hex()}"')
                else:
                    input_parts.append(f"            /* {k}: {v} */")

            if input_parts:
                lines.append(",\n".join(input_parts))
            lines.append("        );")
        else:
            # No known target_function — emit a low-level call with available inputs
            lines.append(f"        // Primitive '{primitive.name}' has no resolved function selector")
            if step.concrete_inputs:
                # Encode inputs as raw calldata for a low-level call
                input_comments = [
                    f"        //   {k}: {v}" for k, v in step.concrete_inputs.items()
                ]
                lines.extend(input_comments)
            if step.concrete_value > 0:
                lines.append(
                    f"        (bool ok, ) = address(target).call{{value: {step.concrete_value}}}(\"\");"
                )
            else:
                lines.append(
                    '        (bool ok, ) = address(target).call("");'
                )
            lines.append('        require(ok, "Low-level call failed");')

        return "\n".join(lines)


# ── Main Exploit Chain Composer ──────────────────────────────────────────────

class ExploitChainComposer:
    """Complete exploit chain composition engine.

    Automatically composes multi-step exploit sequences by chaining
    atomic attack primitives. Uses predefined templates and finding-guided
    synthesis to create actionable PoC exploits.

    Usage:
        composer = ExploitChainComposer()
        result = composer.compose(
            goals=[ExploitGoal.DRAIN_FUNDS, ExploitGoal.PROOF_BYPASS],
            target_contract="PrivacyRouter",
            findings=fuzzing_findings,
        )
    """

    def __init__(
        self,
        max_chain_length: int = 10,
        max_chains_per_goal: int = 10,
    ) -> None:
        self._library = AttackPrimitiveLibrary()
        self._builder = ExploitChainBuilder(
            library=self._library,
            max_chain_length=max_chain_length,
            max_chains=max_chains_per_goal,
        )
        self._poc_generator = ExploitPoCGenerator()

    def compose(
        self,
        goals: list[ExploitGoal] | None = None,
        target_contract: str = "",
        target_invariant: str = "",
        findings: list[dict[str, Any]] | None = None,
        generate_pocs: bool = True,
    ) -> ComposerResult:
        """Compose exploit chains for given goals."""
        start = time.time()
        result = ComposerResult(
            primitives_available=self._library.primitive_count,
        )

        # Default: try all goals
        if not goals:
            goals = list(ExploitGoal)

        all_chains: list[ExploitChain] = []

        for goal in goals:
            chains = self._builder.build_chains(
                goal=goal,
                target_contract=target_contract,
                target_invariant=target_invariant,
                findings=findings,
            )

            result.combinations_explored += len(chains)

            for chain in chains:
                # Generate PoC
                if generate_pocs:
                    chain.poc_code = self._poc_generator.generate(
                        chain, target_contract or "Target",
                    )

                all_chains.append(chain)

                # Track stats
                goal_name = chain.goal.value
                result.by_goal[goal_name] = result.by_goal.get(goal_name, 0) + 1
                status = chain.status.value
                result.by_status[status] = result.by_status.get(status, 0) + 1

        # Sort by soul relevance and complexity
        all_chains.sort(
            key=lambda c: (c.soul_relevance, -c.complexity),
            reverse=True,
        )

        result.chains = all_chains
        result.valid_chains = sum(
            1 for c in all_chains
            if c.status in (ChainStatus.COMPLETE, ChainStatus.VALIDATED)
        )
        result.composition_time_sec = time.time() - start

        logger.info(
            "Exploit composition complete: %d chains, %d valid, %.1fs",
            len(all_chains),
            result.valid_chains,
            result.composition_time_sec,
        )

        return result

    def compose_for_violations(
        self,
        violations: list[dict[str, Any]],
        target_contract: str = "",
    ) -> ComposerResult:
        """Compose exploit chains specifically for detected violations."""
        # Map violations to goals
        goals: list[ExploitGoal] = []
        for v in violations:
            inv_id = v.get("invariant_id", "")
            goal = self._invariant_to_goal(inv_id)
            if goal and goal not in goals:
                goals.append(goal)

        return self.compose(
            goals=goals or [ExploitGoal.DRAIN_FUNDS],
            target_contract=target_contract,
            findings=violations,
            generate_pocs=True,
        )

    def _invariant_to_goal(self, invariant_id: str) -> ExploitGoal | None:
        """Map invariant ID to exploit goal."""
        mapping = {
            "SOUL-INV-001": ExploitGoal.NULLIFIER_REPLAY,
            "SOUL-INV-002": ExploitGoal.DOUBLE_SPEND,
            "SOUL-INV-003": ExploitGoal.DOUBLE_SPEND,
            "SOUL-INV-010": ExploitGoal.PROOF_BYPASS,
            "SOUL-INV-011": ExploitGoal.DOUBLE_SPEND,
            "SOUL-INV-020": ExploitGoal.PROOF_BYPASS,
            "SOUL-INV-030": ExploitGoal.DRAIN_FUNDS,
            "SOUL-INV-033": ExploitGoal.INFLATION_ATTACK,
            "SOUL-INV-040": ExploitGoal.BRIDGE_DOUBLE_SPEND,
            "SOUL-INV-041": ExploitGoal.DRAIN_FUNDS,
            "SOUL-INV-060": ExploitGoal.PRIVILEGE_ESCALATION,
            "SOUL-INV-080": ExploitGoal.DRAIN_FUNDS,
            "SOUL-INV-090": ExploitGoal.STORAGE_CORRUPTION,
        }
        return mapping.get(invariant_id)
